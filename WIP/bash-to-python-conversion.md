# Bash→Python Conversion Plan

> Temporary working document. Authoritative until conversion is complete, then archive.
> Decisions backing this plan are logged in DECISIONS.md (2026-03-01 entries).

## Scope

Convert ALL bash in auto-sdd/scripts/ and auto-sdd/lib/ to Python. No bash remainders.
stakd/ scripts are build artifacts — not conversion targets, regenerated by build loop.

## Conversion targets

| File | Lines | Role | Phase |
|---|---|---|---|
| lib/reliability.sh | 594 | Backoff, locking, crash recovery | 1 (parallel) |
| lib/eval.sh | 391 | Quality scoring | 1 (parallel) |
| lib/codebase-summary.sh | 269 | Context generation for agents | 1 (parallel) |
| lib/validation.sh | ~200 | Validation helpers | 1 (parallel) |
| scripts/eval-sidecar.sh | 393 | Parallel eval during builds | 2 (after eval.py) |
| scripts/build-loop-local.sh | 2,299 | Core orchestrator | 4 (after all libs) |
| scripts/overnight-autonomous.sh | 1,310 | Scheduling, monitoring, auto-restart | 5 (after build-loop) |
| lib/claude-wrapper.sh | ~100 | CLI invocation + cost logging | 6 (bundle) |
| scripts/generate-mapping.sh | 318 | Feature mapping | 6 (bundle) |
| scripts/nightly-review.sh | 170 | Review generation | 6 (bundle) |
| scripts/setup-overnight.sh | small | launchd setup | 6 (bundle) |
| scripts/uninstall-overnight.sh | small | launchd teardown | 6 (bundle) |
| tests/* | ~2,300 | Test suite (5 files) | with each target |

## Phases

Phase 0: Conventions doc + build-loop-local internal structure analysis (chat)
Phase 1: Parallel lib conversion — 4 agents, zero cross-deps
Phase 2: eval-sidecar (sequential, depends on eval.py)
Phase 3: build-loop-local decomposition analysis (chat — read file, identify sub-units)
Phase 4: build-loop-local conversion (possibly 2-3 agents on sub-units)
Phase 5: overnight-autonomous conversion
Phase 6: Small utilities bundle — all remaining files, 1 agent
Phase 7: Integration testing — end-to-end dry run

## Parallel execution logic

Phase 1 runs 4 independent agent sessions simultaneously:
- Agent A: lib/reliability.sh → lib/reliability.py + tests/test_reliability.py
- Agent B: lib/eval.sh → lib/eval.py + tests/test_eval.py
- Agent C: lib/codebase-summary.sh → lib/codebase_summary.py + tests/test_codebase_summary.py
- Agent D: lib/validation.sh → lib/validation.py + tests/test_validation.py

Each agent gets: its bash source, its test file, the conventions doc.
Each agent outputs to a dedicated feature branch (e.g., convert/reliability, convert/eval).
No agent touches files outside its unit.

Integration after Phase 1:
- Brian merges all 4 branches to a convert/libs-integrated branch
- Runs full test suite to catch convention drift or interface mismatches
- Fixes any integration issues before proceeding to Phase 2

Phase 4 (build-loop-local) parallelization is conditional:
- Phase 3 decomposes the file into sub-units
- If sub-units have clean boundaries (e.g., init, feature loop, retry/recovery,
  cost tracking, signal handling, reporting), they can parallelize like Phase 1
- If sub-units share mutable state or interleave heavily, convert sequentially
- Decision made during Phase 3, not before

All other phases are single-agent sequential. No parallelization benefit —
each depends on the previous phase's output.

## Constraints

- Preserve existing file-based state formats (migration is a separate project)
- Each agent prompt follows prompt-engineering-guide constraints
- Tests convert alongside their target (same agent prompt)
- One agent prompt per conversion unit — tight scope, fresh context
- Agent must not modify files outside its assigned unit

## Key decisions (details in DECISIONS.md)

- Libs first: dependency graph requires it
- File-based state preserved: one variable at a time
- All bash converts: no split-language maintenance
- Conventions doc before parallel work: prevents integration failures
- stakd/ is build artifact: not a conversion target

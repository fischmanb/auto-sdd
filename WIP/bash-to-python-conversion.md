# Bash→Python Conversion Plan

> Temporary working document. Authoritative until conversion is complete, then archive.
> Decisions backing this plan are logged in DECISIONS.md (2026-03-01 entries).

## Scope

Convert bash orchestration in auto-sdd/scripts/ and auto-sdd/lib/ to Python.
stakd/ scripts are build artifacts — not conversion targets, regenerated by build loop.
**Launchd scripts (setup-overnight.sh, uninstall-overnight.sh) stay bash** — system bootstrap wrappers, plist/launchctl, no value in converting.

## Coexistence rule

**Original bash files stay intact.** No moves, no renames, no deletions. Python lives in a completely separate `py/` tree. Both coexist indefinitely. This is not a phased deletion plan — it's a parallel implementation. The bash versions remain as reference, fallback, and operational baseline. Deletion is a separate future decision requiring its own justification.

**Directory structure:**
```
auto-sdd/
├── scripts/                  # UNTOUCHED — original bash
├── lib/                      # UNTOUCHED — original bash
├── tests/                    # UNTOUCHED — original bash tests
├── py/                       # ALL Python lives here
│   ├── auto_sdd/             # Python package
│   │   ├── __init__.py
│   │   ├── lib/
│   │   │   ├── __init__.py
│   │   │   ├── reliability.py
│   │   │   ├── eval_lib.py
│   │   │   ├── codebase_summary.py
│   │   │   ├── validation.py
│   │   │   ├── claude_wrapper.py
│   │   │   ├── signals.py       # Signal protocol constants + emitters
│   │   │   └── state.py         # Shared state I/O patterns
│   │   ├── scripts/
│   │   │   ├── build_loop.py
│   │   │   ├── eval_sidecar.py
│   │   │   ├── overnight.py
│   │   │   ├── generate_mapping.py
│   │   │   └── nightly_review.py
│   │   └── conventions.md       # Conventions doc (lives with the code it governs)
│   ├── tests/
│   │   ├── conftest.py          # Shared fixtures
│   │   ├── test_reliability.py
│   │   ├── test_eval.py
│   │   ├── test_codebase_summary.py
│   │   ├── test_validation.py
│   │   ├── test_claude_wrapper.py
│   │   └── test_integration.py  # Phase 7
│   ├── pyproject.toml
│   └── README.md                # Python-specific setup/run docs
├── scripts/setup-overnight.sh   # STAYS BASH
├── scripts/uninstall-overnight.sh # STAYS BASH
```

## Conversion targets

| File | Lines | Role | Phase |
|---|---|---|---|
| lib/reliability.sh | 594 | Backoff, locking, crash recovery | 1 (parallel) |
| lib/eval.sh | 391 | Quality scoring | 1 (parallel) |
| lib/codebase-summary.sh | 269 | Context generation for agents | 1 (parallel) |
| lib/validation.sh | ~200 | Validation helpers | 1 (parallel) |
| lib/claude-wrapper.sh | ~100 | CLI invocation + cost logging | 1 (parallel) |
| scripts/eval-sidecar.sh | 393 | Parallel eval during builds | 2 (after eval.py) |
| scripts/build-loop-local.sh | 2,299 | Core orchestrator | 4 (after all libs) |
| scripts/overnight-autonomous.sh | 1,310 | Scheduling, monitoring, auto-restart | 5 (after build-loop) |
| scripts/generate-mapping.sh | 318 | Feature mapping | 6 (bundle) |
| scripts/nightly-review.sh | 170 | Review generation | 6 (bundle) |
| tests/* | ~2,300 | Test suite (5 files) | with each target |

## Phases

Phase 0: Conventions doc + interface stubs + build-loop-local internal structure analysis (chat)
Phase 1: Parallel lib conversion — 5 agents, zero cross-deps (reliability, eval, codebase-summary, validation, claude-wrapper)
Phase 2: eval-sidecar (sequential, depends on eval.py)
Phase 3: build-loop-local decomposition analysis (chat — identify sub-units)
Phase 4: build-loop-local conversion (possibly 2-3 agents on sub-units, sequential integration)
Phase 5: overnight-autonomous conversion
Phase 6: Small utilities bundle — generate-mapping, nightly-review (1 agent)
Phase 7: Integration testing — end-to-end dry run

## Parallel execution logic

Phase 1 runs 5 independent agent sessions simultaneously (Claude Code desktop app, one tab each):
- Agent A: lib/reliability.sh → py/auto_sdd/lib/reliability.py + py/tests/test_reliability.py
- Agent B: lib/eval.sh → py/auto_sdd/lib/eval_lib.py + py/tests/test_eval.py
- Agent C: lib/codebase-summary.sh → py/auto_sdd/lib/codebase_summary.py + py/tests/test_codebase_summary.py
- Agent D: lib/validation.sh → py/auto_sdd/lib/validation.py + py/tests/test_validation.py
- Agent E: lib/claude-wrapper.sh → py/auto_sdd/lib/claude_wrapper.py + py/tests/test_claude_wrapper.py

Each agent gets: its bash source, its bash test file, the conventions doc (with interface stubs), branch instructions.
Each agent outputs to a dedicated feature branch (e.g., convert/reliability, convert/eval).
No agent touches files outside its unit.

Integration after Phase 1:
- Brian merges all 5 branches to a convert/libs-integrated branch
- Runs full test suite to catch convention drift or interface mismatches
- Fixes any integration issues before proceeding to Phase 2

Phase 4 (build-loop-local) parallelization is conditional:
- Phase 3 decomposes the file into sub-units
- If sub-units have clean boundaries, they can parallelize like Phase 1
- If sub-units share mutable state or interleave heavily, convert sequentially
- Decision made during Phase 3, not before

All other phases are single-agent sequential.

## Conventions doc scope (Phase 0 deliverable)

The conventions doc must cover ALL of the following before any agent starts:
- Python 3.12+ minimum
- Error handling: typed exception hierarchy (AutoSddError base, BuildFailedError, CreditExhaustedError, LockContentionError, AgentTimeoutError)
- Subprocess patterns: run_claude() wrapper with generous configurable timeout (default 10 min)
- Logging: stdlib logging, levels mapped from bash [INFO]/[WARN]/[ERROR]/[DEBUG], FileHandler for build logs
- Signal protocol preservation: all signals remain flat grep-parseable strings at the boundary. signals.py module with constants + emit functions. Python internals can use any structure.
- File-based state I/O: atomic writes (temp-file-then-rename), fcntl.flock() for locking, shared read/write helpers in state.py
- Type hints: all code fully typed, mypy --strict as validation gate
- Test patterns: pytest, shared conftest.py with fixtures (tmp_project, mock_claude_output), plain assert with messages, test_{function}_{scenario} naming
- Interface stubs: function signatures that build-loop-local calls from each lib — contracts the agents must implement
- Dependencies: stdlib + pytest only, no third-party without approval
- Package management: pyproject.toml + pip install -e .

## Constraints

- **Bash originals untouched** — coexistence, not replacement
- Preserve existing file-based state formats (migration is a separate project)
- Each agent prompt follows prompt-engineering-guide constraints
- Tests convert alongside their target (same agent prompt)
- One agent prompt per conversion unit — tight scope, fresh context
- Agent must not modify files outside its assigned unit
- Phase separations respect context window limits — no combining phases to save calendar time

## Key decisions (details in DECISIONS.md)

- Claude-wrapper moved to Phase 1: leaf node, build-loop needs it, self-contained
- Libs first: dependency graph requires it
- File-based state preserved: one variable at a time
- Launchd scripts stay bash: system bootstrap, no conversion value
- Bash originals preserved indefinitely: separate py/ tree, no deletion plan
- Conventions doc before parallel work: prevents integration failures
- Conventions doc includes interface stubs: prevents Phase 4 interface drift
- stakd/ is build artifact: not a conversion target

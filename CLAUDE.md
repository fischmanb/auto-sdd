# Spec-Driven Development (SDD)

This project uses a spec-driven development workflow. Follow these rules in all interactions.

## Core Principle

**Spec before code.** Define behavior before implementing it.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   DESIGN    â”‚ â”€â”€â–¶ â”‚    SPEC     â”‚ â”€â”€â–¶ â”‚    TEST     â”‚ â”€â”€â–¶ â”‚ IMPLEMENT   â”‚
â”‚ (tokens +   â”‚     â”‚ (Gherkin +  â”‚     â”‚  (failing)  â”‚     â”‚ (loop until â”‚
â”‚  stubs)     â”‚     â”‚  mockup)    â”‚     â”‚             â”‚     â”‚ tests pass) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Directory Structure

```
.specs/
â”œâ”€â”€ vision.md              # App vision (created by /vision or /clone-app)
â”œâ”€â”€ roadmap.md             # Feature roadmap (single source of truth)
â”œâ”€â”€ features/              # Gherkin specs with ASCII mockups
â”‚   â””â”€â”€ {domain}/
â”‚       â””â”€â”€ {feature}.feature.md
â”œâ”€â”€ test-suites/           # Test documentation
â”‚   â””â”€â”€ {mirrors test dir structure}
â”œâ”€â”€ design-system/         # Design tokens and patterns
â”‚   â”œâ”€â”€ tokens.md          # Colors, spacing, typography
â”‚   â””â”€â”€ components/        # Component pattern docs
â”‚       â””â”€â”€ {component}.md
â”œâ”€â”€ learnings/             # Cross-cutting patterns by category
â”‚   â”œâ”€â”€ index.md           # Summary
â”‚   â”œâ”€â”€ testing.md
â”‚   â”œâ”€â”€ performance.md
â”‚   â”œâ”€â”€ security.md
â”‚   â”œâ”€â”€ api.md
â”‚   â”œâ”€â”€ design.md
â”‚   â””â”€â”€ general.md
â”œâ”€â”€ mapping.md             # AUTO-GENERATED from spec frontmatter
â”œâ”€â”€ codebase-summary.md    # Generated by /spec-init
â””â”€â”€ needs-review.md        # Files that need manual attention
```

---

## When Implementing Features

### For New Features
1. Check if spec exists in `.specs/features/`
2. If not, create one with Gherkin scenarios + ASCII mockup
3. Reference design tokens in mockups
4. Create component stubs for new UI components
5. **STOP for approval** before writing tests
6. Write failing tests
7. Implement until tests pass
8. Fill in component documentation

### For Existing Features
1. Read the feature spec first
2. Update spec if behavior changes
3. Update tests to match
4. Update `.specs/mapping.md`

### For Bug Fixes
1. Check if spec defines expected behavior
2. If gap found, add scenario to spec
3. Write failing test that reproduces bug
4. Fix the bug
5. Document the new test

---

## Pause Triggers

If the user says any of these, create the spec and **STOP** - wait for approval:
- "let me review first"
- "write the spec first"
- "spec this out"
- "don't implement yet"
- "plan this first"
- "hold on" / "wait"

After showing spec: "Does this look right? Ready to write tests?"
After tests written: "Tests written (failing). Ready to implement?"

---

## Feature Spec Format

Every feature spec should include:

```markdown
# Feature Name

**Source File**: path/to/file.tsx
**Design System**: .specs/design-system/tokens.md

## Feature: [Name]

### Scenario: [Happy path]
Given [precondition]
When [action]
Then [expected result]

### Scenario: [Edge case]
...

## UI Mockup

(ASCII art showing component layout)

## Component References

- Button: .specs/design-system/components/button.md
```

---

## Design System

This project uses design tokens defined in `.specs/design-system/tokens.md`.

### Token Reference

When implementing UI, use these token names (not hardcoded values):

**Colors:**
- `color-primary`, `color-secondary` - Brand colors
- `color-background`, `color-surface` - Backgrounds
- `color-text`, `color-text-secondary` - Text
- `color-error`, `color-success`, `color-warning` - Semantic

**Typography:**
- `text-xs` through `text-5xl` - Font sizes
- `font-normal`, `font-medium`, `font-semibold`, `font-bold` - Weights

**Spacing:**
- `spacing-1` through `spacing-16` - Spacing scale

**Border Radius:**
- `radius-sm`, `radius-md`, `radius-lg`, `radius-xl`, `radius-full`

**Shadows:**
- `shadow-sm`, `shadow-md`, `shadow-lg`, `shadow-xl`

### Design System Maintenance

The token summary above should stay in sync with `.specs/design-system/tokens.md`.

When design tokens change:
1. Update `.specs/design-system/tokens.md` (source of truth)
2. Update the token summary in this CLAUDE.md file
3. Update any affected component documentation

When new components are created:
1. Create stub in `.specs/design-system/components/`
2. After implementation, fill in with `/design-component`

---

## Component Stub Lifecycle

```
1. /spec-first "user profile"
   â””â”€â–¶ Mockup references "Card" component
   â””â”€â–¶ Card doesn't exist â†’ CREATE STUB

2. Stub created: .specs/design-system/components/card.md
   Status: ğŸ“ Stub (pending implementation)

3. Implementation happens...

4. /design-component card
   â””â”€â–¶ Reads actual component code
   â””â”€â–¶ Fills in props, variants, usage examples
   â””â”€â–¶ Status: âœ… Documented
```

---

## Available Commands

### Setup
| Command | Purpose |
|---------|---------|
| `/spec-init` | Bootstrap on existing codebase |
| `/spec-first` | Create spec + mockup for new feature |
| `/spec-first --full` | Create spec AND build without pauses |

### Core Workflow
| Command | Purpose |
|---------|---------|
| `/document-code` | Generate specs from existing code |
| `/prototype` | Rapid prototyping without specs |
| `/formalize` | Convert prototype to production with specs |
| `/compound` | Extract and persist learnings from session |

### Roadmap Commands
| Command | Purpose |
|---------|---------|
| `/vision` | Create or update vision.md from description, Jira, or Confluence |
| `/roadmap` | Create, update, or restructure roadmap.md |
| `/clone-app <url>` | Analyze app â†’ create vision.md + roadmap.md |
| `/build-next` | Build next pending feature from roadmap |
| `/roadmap-triage` | Scan Slack/Jira â†’ add to roadmap |

### Design System
| Command | Purpose |
|---------|---------|
| `/design-tokens` | Create or update design tokens |
| `/design-component` | Document a component pattern |

### Bug Fixing and Refactoring
| Command | Purpose |
|---------|---------|
| `/fix-bug` | Fix bugs with regression tests |
| `/refactor` | Refactor while keeping tests green |

### Documentation and Maintenance
| Command | Purpose |
|---------|---------|
| `/check-coverage` | Find gaps in spec/test coverage |
| `/update-test-docs` | Sync test docs with actual tests |
| `/catch-drift` | Detect spec â†” code drift |
| `/verify-test-counts` | Reconcile test counts |

### Git Workflow
| Command | Purpose |
|---------|---------|
| `/start-feature` | Create new feature branch |
| `/code-review` | Review against engineering standards |

---

## Test ID Conventions

| Prefix | Component/Module |
|--------|------------------|
| UT | utils |
| API | api handlers |
| SVC | services |
| CMP | components |
| PG | pages |
| HK | hooks |

---

## Always Mention

When working with specs, always tell the user:
- Which spec files you're reading/creating/updating
- Which design system files you're referencing
- Any gaps between specs and tests
- Component stubs that need documentation

---

## File Locations

| Type | Location |
|------|----------|
| App vision | `.specs/vision.md` |
| Build roadmap | `.specs/roadmap.md` |
| Feature specs | `.specs/features/{domain}/{feature}.feature.md` |
| Test suite docs | `.specs/test-suites/{mirrors test dir}` |
| Design tokens | `.specs/design-system/tokens.md` |
| Component docs | `.specs/design-system/components/{name}.md` |
| Mapping | `.specs/mapping.md` (auto-generated) |
| Cross-cutting learnings | `.specs/learnings/` (by category) |

---

## Mapping File

The `.specs/mapping.md` file is **auto-generated** from feature spec YAML frontmatter.

**Do not edit mapping.md directly.** Instead:
1. Update the feature spec's YAML frontmatter
2. The Cursor hook will regenerate mapping.md automatically
3. Or run `./scripts/generate-mapping.sh` manually

### Feature Spec Frontmatter

Every feature spec should have YAML frontmatter:

```yaml
---
feature: Feature Name
domain: domain-name
source: path/to/source.tsx
tests:
  - path/to/test.ts
components:
  - ComponentName
status: stub | specced | tested | implemented
created: YYYY-MM-DD
updated: YYYY-MM-DD
---
```

---

## Learnings

Cross-cutting learnings are stored in `.specs/learnings/` by category:

| Category | File |
|----------|------|
| Testing | `.specs/learnings/testing.md` |
| Performance | `.specs/learnings/performance.md` |
| Security | `.specs/learnings/security.md` |
| API & Data | `.specs/learnings/api.md` |
| Design System | `.specs/learnings/design.md` |
| General | `.specs/learnings/general.md` |

Read `.specs/learnings/index.md` for a summary and recent learnings.

Feature-specific learnings are in each spec's `## Learnings` section.

Run `/compound` at the end of implementation sessions to extract and persist learnings.

---

## Roadmap System

For building entire apps, use the roadmap system:

### vision.md

High-level app description:
- What the app does
- Target users
- Key screens
- Tech stack

Created by `/vision` (from description, Jira, or Confluence) or `/clone-app <url>` (from a live app).

### roadmap.md

Ordered list of features with dependencies and status:

```markdown
| # | Feature | Source | Jira | Complexity | Deps | Status |
|---|---------|--------|------|------------|------|--------|
| 1 | Auth: Signup | clone-app | PROJ-101 | M | - | âœ… |
| 2 | Dashboard | clone-app | PROJ-102 | L | 1 | â¬œ |
```

Status symbols:
- â¬œ Pending
- ğŸ”„ In Progress
- âœ… Completed
- â¸ï¸ Blocked
- âŒ Cancelled

### Creating and Updating

| Command | Purpose |
|---------|---------|
| `/vision` | Create or update vision.md from description, Jira, or Confluence |
| `/roadmap` | Create, add features, reprioritize, or check status |
| `/roadmap add "feature"` | Add a feature or phase to existing roadmap |
| `/roadmap reprioritize` | Restructure phases and reorder features |
| `/roadmap status` | Read-only progress report |
| `/clone-app <url>` | Analyze a live app â†’ create both vision.md + roadmap.md |

### Building from Roadmap

1. `/vision` or `/clone-app` creates vision.md
2. `/roadmap` or `/clone-app` creates roadmap.md
3. `/build-next` picks next pending feature (deps met)
4. Runs `/spec-first --full` to build it (includes self-check drift)
5. Build loop runs fresh-agent drift check (Layer 2)
6. Updates roadmap status
7. Repeat until done

### Triage

`/roadmap-triage` scans Slack/Jira and adds items to the "Ad-hoc Requests" section of roadmap.md.

---

## Drift Enforcement

Specâ†”code drift is enforced at two layers:

### Layer 1: Self-Check (same agent, lightweight)

Built into `/spec-first --full` between implement and compound:
- The build agent re-reads its own Gherkin scenarios
- Compares against what it actually implemented
- Fixes obvious mismatches before committing

This is cheap (same context) but has the "fox guarding henhouse" limitation.

### Layer 2: Fresh-Agent Cross-Check (separate agent, thorough)

Built into `build-loop-local.sh` and `overnight-autonomous.sh`:
- After the build agent commits, a **separate agent** is spawned
- It reads the spec file and source files with fresh context
- Reports `NO_DRIFT`, `DRIFT_FIXED`, or `DRIFT_UNRESOLVABLE`
- Feature is only marked complete if drift is clean

### Signal Protocol

The build agent MUST output these signals for drift checking:

```
FEATURE_BUILT: {feature name}
SPEC_FILE: {path to .feature.md file}
SOURCE_FILES: {comma-separated source file paths}
```

The drift-check agent MUST output one of:

```
NO_DRIFT
DRIFT_FIXED: {summary of what was reconciled}
DRIFT_UNRESOLVABLE: {what needs human attention}
```

### Configuration

In `.env.local`:

```bash
DRIFT_CHECK=true          # Enable/disable drift checking (default: true)
MAX_DRIFT_RETRIES=1       # Retry attempts for fixing drift (default: 1)
```

---

## Implementation Rules

- Seed data is acceptable. Use seed data, fixtures, or realistic sample data to make features functional.
- NO stub functions that return hardcoded values or TODO placeholders. Every function must contain real logic.
- NO placeholder UI. Components must be wired to real data sources.
- Features must work end-to-end or they are not done.
- Real validation, real error handling, real flows.

## Onboarding State Protocol

If `~/auto-sdd/.onboarding-state` exists, follow the update protocol documented in `ONBOARDING.md` under "Keeping This File Current." This applies to all agents and chat instances working on this project.
